#!/bin/sh

[ -f "/etc/service_template" ] && . "/etc/service_template"

user_exists()
{
    id $1 > /dev/null 2>&1
}

wait_for_user_and_package()
{
    sleep 1
    i=0
    while [ $i -lt 12 ]
    do
        sleep 1
        if [ $i -eq 11 ]; then
            dev_log_debug 'user _c_mgmt or package does not exist, exiting'
            exit 1
        elif [ $( dpkg -l | grep -c c_mgmt ) -eq 0 ] ; then
            dev_log_debug 'package c_mgmt does not exist, retry'
        elif ! id -u _c_mgmt  > /dev/null 2>&1 ; then
            dev_log_debug 'user _c_mgmt  does not exist, retry'
        else
            dev_log_debug 'found user _c_mgmt and package c_mgmt, continue'
            break
        fi
        i=`expr $i + 1`
    done
}

copy_passwd_file()
{
    STAGING_DIR='/tandberg/'
    BASE_FILE='c_mgmt.passwd'
    PASSWD_DIR='/tandberg/etc/passwd.d/'
    VERSION=$(echo $(cat /info/product_info.xml) | sed "s;.*<version>.*<major>\([^<]*\)</major>.*<minor>\([^<]*\)</minor>.*;\1.\2;")

    if [ -f ${STAGING_DIR}${VERSION}${BASE_FILE} ] ; then
        mv ${STAGING_DIR}${VERSION}${BASE_FILE} ${PASSWD_DIR}${BASE_FILE}
        wait_for_user_and_package
    fi
    rm -f ${STAGING_DIR}*${BASE_FILE}
}

init_files()
{
    copy_passwd_file

    c_mgmt_uid="804"

    # Created as part of CCUC Solutions support
    if [ ! -d /var/run/c_ccucmgmt ]; then
        mkdir -p /var/run/c_ccucmgmt
    fi

    if [ ! -d /tandberg/persistent/fusion/config ]; then
        mkdir -p /tandberg/persistent/fusion/config
    fi

    if [ ! -d /mnt/harddisk/current/fusion/template ]; then
        mkdir -p /mnt/harddisk/current/fusion/template
    fi

    if [ ! -d /mnt/harddisk/current/fusion/manifest ]; then
        mkdir -p /mnt/harddisk/current/fusion/manifest
    fi

    if [ -f /tandberg/c_mgmt_manifest.json ]; then
        mv /tandberg/c_mgmt_manifest.json /mnt/harddisk/current/fusion/manifest/c_mgmt.json
    fi

    if [ -f /tandberg/c_mgmt_template.json ]; then
        mv /tandberg/c_mgmt_template.json /mnt/harddisk/current/fusion/template/c_mgmt_template.json
    fi

    # On startup ensure there is no stale installing file.
    if [ -f /var/run/c_mgmt/installing_status.json ]; then
        rm /var/run/c_mgmt/installing_status.json
    fi

    # On startup ensure there is no stale installing file.
    if [ -f /var/run/c_ccucmgmt/installing_status.json ]; then
        rm /var/run/c_ccucmgmt/installing_status.json
    fi

    # Change ownership of the c_mgmt connector files and directories
    # Fusion
    chown _c_mgmt:_c_mgmt /tandberg/persistent/fusion

    # Config
    chown -R _c_mgmt:_c_mgmt /tandberg/persistent/fusion/config

    # Manifest
    chown _c_mgmt:_c_mgmt /mnt/harddisk/current/fusion/manifest
    if [ -f /mnt/harddisk/current/fusion/manifest/c_mgmt.json ]; then
        chown _c_mgmt:_c_mgmt /mnt/harddisk/current/fusion/manifest/c_mgmt.json
    fi

    # Template Section
    chown _c_mgmt:_c_mgmt /mnt/harddisk/current/fusion/template
    if [ -f /mnt/harddisk/current/fusion/template/c_mgmt_template.json ]; then
        chown _c_mgmt:_c_mgmt /mnt/harddisk/current/fusion/template/c_mgmt_template.json
    fi

    # /mnt/harddisk/persistent/fusion section
    if [ ! -d /mnt/harddisk/persistent/fusion/ ]; then
        mkdir /mnt/harddisk/persistent/fusion/
    fi

    file_uid=`stat -c "%u" /mnt/harddisk/persistent/fusion/`
    if [ $file_uid != $c_mgmt_uid ]; then
        chown -R _c_mgmt:_c_mgmt /mnt/harddisk/persistent/fusion/
    fi

    PREV_TLP_DIR=/mnt/harddisk/persistent/fusion/previousversions
    CUR_TLP_DIR=/mnt/harddisk/persistent/fusion/currentversions
    DOWNLOADS_TLP_DIR=/mnt/harddisk/persistent/fusion/downloads

    # Logging Section
    if [ ! -d /mnt/harddisk/persistent/fusion/log ]; then
        mkdir /mnt/harddisk/persistent/fusion/log
    fi

    file_uid=`stat -c "%u" /mnt/harddisk/persistent/fusion/log`
    if [ $file_uid != $c_mgmt_uid ]; then
        chown -R _c_mgmt:_c_mgmt /mnt/harddisk/persistent/fusion/log/
    fi


    # Prev Versions Section
    if [ ! -d ${PREV_TLP_DIR} ]; then
        mkdir ${PREV_TLP_DIR}
    fi

    file_uid=`stat -c "%u" ${PREV_TLP_DIR}`
    if [ $file_uid != $c_mgmt_uid ]; then
        chown -R _c_mgmt:_c_mgmt ${PREV_TLP_DIR}
    fi


    # Current Versions Section

    if [ ! -d ${CUR_TLP_DIR} ]; then
        mkdir ${CUR_TLP_DIR}
    fi


    file_uid=`stat -c "%u" ${CUR_TLP_DIR}`
    if [ $file_uid != $c_mgmt_uid ]; then
        chown -R _c_mgmt:_c_mgmt ${CUR_TLP_DIR}
    fi

    # Downloads Section

    if [ ! -d ${DOWNLOADS_TLP_DIR} ]; then
        mkdir ${DOWNLOADS_TLP_DIR}
    fi


    file_uid=`stat -c "%u" ${DOWNLOADS_TLP_DIR}`
    if [ $file_uid != $c_mgmt_uid ]; then
        chown -R _c_mgmt:_c_mgmt ${DOWNLOADS_TLP_DIR}
    fi

    # ensure there is a fusion status dir
    if [ ! -d /tandberg/persistent/fusion/status ]; then
        mkdir /tandberg/persistent/fusion/status
        chown _c_mgmt:_c_mgmt /tandberg/persistent/fusion/status 
        chmod 777 /tandberg/persistent/fusion/status
    fi


    CONFIG_FILE=/tandberg/persistent/fusion/config/c_mgmt.json
    FUSION_STATE=`cat ${CONFIG_FILE} 2>/dev/null | get_json_value fused`

    if [ `ls -l ${CUR_TLP_DIR}/c_mgmt*.tlp 2>/dev/null | wc -l` -eq 0 ] || [ "${FUSION_STATE}" != "true" ]; then
        if [ `ls -l /tandberg/c_mgmt*.tlp 2>/dev/null | wc -l` -gt 0 ]; then
            if [ `ls -l ${CUR_TLP_DIR}/c_mgmt*.tlp 2>/dev/null | wc -l` -gt 0 ]; then
                # Explicitly remove last base TLP
                rm ${CUR_TLP_DIR}/c_mgmt*.tlp
            fi
            MOST_RECENT=`ls -t /tandberg/c_mgmt*.tlp 2>/dev/null | head -1`
            mv ${MOST_RECENT} ${PREV_TLP_DIR}/
            chown _c_mgmt:_c_mgmt ${PREV_TLP_DIR}/c_mgmt*.tlp
        fi
    fi
    if [ `ls -l /tandberg/c_mgmt*.tlp 2>/dev/null | wc -l` -gt 0 ]; then
        rm /tandberg/c_mgmt*.tlp
    fi

    # This should hopefully never happen. But after the above TLP processing if we get
    # here and still have more than one c_mgmt*.tlp at currentversions then delete
    # all except the most recent via timestamp (best effort at keeping the correct one)
    if [ `ls -l ${CUR_TLP_DIR}/c_mgmt*.tlp 2>/dev/null | wc -l` -gt 1 ]; then
        MOST_RECENT=`ls -t ${CUR_TLP_DIR}/c_mgmt*.tlp 2>/dev/null | head -1`
        mv ${MOST_RECENT} /tmp/
        rm ${CUR_TLP_DIR}/c_mgmt*.tlp
        TMP_BACKUP=`ls -t /tmp/c_mgmt*.tlp 2>/dev/null | head -1`
        mv ${TMP_BACKUP} ${CUR_TLP_DIR}
    fi

    # Staging Directory
    if [ -d /tmp/fusion/ ]; then
        file_uid=`stat -c "%u" /tmp/fusion/`
        if [ $file_uid != $c_mgmt_uid ]; then
            chown -R _c_mgmt:_c_mgmt /tmp/fusion/
        fi
    fi

    # Pid file Directory
    if [ -d /var/run/c_mgmt/ ]; then
        chown -R _c_mgmt:_c_mgmt /var/run/c_mgmt/
    fi

    # Pid file Directory
    if [ -d /var/run/c_ccucmgmt/ ]; then
        chown -R _c_mgmt:_c_mgmt /var/run/c_ccucmgmt/
    fi

    #
    # CERTS
    #
    NEW_FUSION_CERTS_TO_ADD=/opt/c_mgmt/etc/certs/*.pem
    PREVIOUSLY_ADDED_FUSION_CERTS_DIR=/tandberg/persistent/certs/fusionadded/
    PREVIOUSLY_ADDED_FUSION_CERTS=$PREVIOUSLY_ADDED_FUSION_CERTS_DIR*.pem
    TEMP_CA_FILE=/tmp/ca.pem
    CA_FILE=/tandberg/persistent/certs/ca.pem
    FUSION_CA=/mnt/harddisk/persistent/fusion/certs

    mkdir -p ${FUSION_CA}

    cat ${NEW_FUSION_CERTS_TO_ADD} > ${FUSION_CA}/fusion.pem
    chown -R _c_mgmt:_c_mgmt ${FUSION_CA}/
}

#
# installwizard:
# no point trying to init files/directories if
# _c_mgmt user isn't there
#
if user_exists _c_mgmt; then
    init_files
fi

dev_log_verbose() {
  # change boolean this if you want verbose
  verbose=false
  if [ "$verbose" = true ]; then
     dev_log_debug "$@"
  fi
}

#
# create CA copy
#
createcacopy() {

  dev_log_verbose "c_mgmt:createcacopy: Create copy of ca"
  cp $CA_FILE $TEMP_CA_FILE 
}

#
# removefusioncerts
#    and remove from /tandberg/persistent/certs/ca.pem, certs /tandberg/persistent/certs/fusionadded/*
#    rm -fr /tandberg/persistent/certs/fusionadded/*
#
removefusioncerts() {

  # if directory exists we know we have been fused
  dev_log_debug "c_mgmt:removefusioncerts: removefusioncerts"
  if [ -d $PREVIOUSLY_ADDED_FUSION_CERTS_DIR ]; then
    
    createcacopy

    # remove unwanted certs
    dev_log_debug "c_mgmt:removefusioncerts: found previous certs"
    for previous_cert in $(find $PREVIOUSLY_ADDED_FUSION_CERTS -type f 2>/dev/null); do 
      dev_log_debug "c_mgmt:removefusioncerts: remove cert $previous_cert from from $TEMP_CA_FILE"
      remove_file $previous_cert $TEMP_CA_FILE   
    done
    dev_log_debug "c_mgmt:removefusioncerts: File different: Create new cert file $CA_FILE"
    cp $TEMP_CA_FILE $CA_FILE
    dev_log_debug "c_mgmt:removefusioncerts: delete directory $PREVIOUSLY_ADDED_FUSION_CERTS_DIR"
    rm -fr $PREVIOUSLY_ADDED_FUSION_CERTS_DIR
  fi
}

#
# addfusioncerts
#    append certs from /opt/c_mgmt/etc/certs/* to /tandberg/persistent/certs/ca.pem
#    certs added are stored here /tandberg/persistent/certs/fusionadded/
#
addfusioncerts() {
  dev_log_debug "c_mgmt:addfusioncerts:"
  dev_log_debug "c_mgmt:addfusioncerts: delete and recreate $PREVIOUSLY_ADDED_FUSION_CERTS_DIR"
  rm -fr $PREVIOUSLY_ADDED_FUSION_CERTS_DIR
  mkdir $PREVIOUSLY_ADDED_FUSION_CERTS_DIR
  updatefusioncerts
}

#
# updatefusioncerts
# delete any cert from CA missing in /opt/c_mgmt/etc/certs/ and not in /tandberg/persistent/certs/fusionadded/
# add additional certs  /opt/c_mgmt/etc/certs/ and not in /tandberg/persistent/certs/fusionadded/
#
updatefusioncerts() {

  dev_log_debug "c_mgmt:updatefusioncerts"

  if [ ! -d $PREVIOUSLY_ADDED_FUSION_CERTS_DIR ]; then
     dev_log_debug "c_mgmt:updatefusioncerts: CA not appended with certs, exit"
     return
  fi 

  createcacopy

  # remove unwanted certs
  # delete any cert from CA missing in /opt/c_mgmt/etc/certs/ and not in /tandberg/persistent/certs/fusionadded/
  if [ -d $PREVIOUSLY_ADDED_FUSION_CERTS_DIR ]; then

    dev_log_debug "c_mgmt:updatefusioncerts: remove unwanted certs (certs that have been preiosuly added, but are not in new bundle)"
    for previous_cert in $(find $PREVIOUSLY_ADDED_FUSION_CERTS -type f 2>/dev/null) ; do  
      found_match="n"
      dev_log_verbose "c_mgmt:updatefusioncerts: Searching for cert: $previous_cert, found_match=$found_match"
      for new_cert in $(find $NEW_FUSION_CERTS_TO_ADD -type f 2>/dev/null) ; do 
         dev_log_verbose "c_mgmt:updatefusioncerts: Matching new: $new_cert and previous: $previous_cert" 
         if cmp $new_cert $previous_cert >/dev/null 2>&1 ; then
             dev_log_verbose "         Found match: $previous_cert"
             found_match="y"
             continue
         fi
      done
      if [ "$found_match" = "y" ] ; then
          dev_log_debug "c_mgmt:updatefusioncerts: Found match, cert still required in CA: $previous_cert"
      else
          dev_log_debug "c_mgmt:updatefusioncerts: Did not find match, remove previous cert $previous_cert from CA"
          remove_file $previous_cert $TEMP_CA_FILE       
          rm $previous_cert
      fi
    done

  fi


  # add new certs
  for new_cert in $(find $NEW_FUSION_CERTS_TO_ADD -type f  2>/dev/null) ; do 

      dev_log_verbose "c_mgmt:updatefusioncerts: Adding  new cert: $new_cert"

      # if already added, don't add again
      # search PREVIOUSLY_ADDED_FUSION_CERTS_DIR directory
      #
      found_match="n"
      if [ -d $PREVIOUSLY_ADDED_FUSION_CERTS_DIR ]; then
         dev_log_verbose "c_mgmt:updatefusioncerts: Searching for cert: $new_cert"
         for previous_cert in $(find $PREVIOUSLY_ADDED_FUSION_CERTS -type f 2>/dev/null) ; do 
            dev_log_verbose "c_mgmt:updatefusioncerts: Matching new: $new_cert and previous: $previous_cert" 
            if cmp $new_cert $previous_cert >/dev/null 2>&1 ; then
                found_match="y"
                dev_log_verbose "c_mgmt:updatefusioncerts: Found match ($found_match): $previous_cert"
                continue
            fi
         done
      fi

      if [ "$found_match" = "y" ] ; then
          dev_log_debug "c_mgmt:updatefusioncerts: Found match, Don't add cert ($new_cert) already added"
      else
          dev_log_debug "c_mgmt:updatefusioncerts: Did not find match, must add cert $previous_cert to CA"
          result=$(search_file $new_cert $TEMP_CA_FILE)
          dev_log_verbose "c_mgmt:updatefusioncerts: Search for cert in CA: $new_cert: result=$result"
          if [ "$result" -eq "-1" ]; then
              dev_log_debug "c_mgmt:updatefusioncerts: Add cert to file to CA: $new_cert"
              echo -e $(get_formatted_certs $new_cert) >> $TEMP_CA_FILE
              clean_blank_lines $TEMP_CA_FILE

              # we need to backup certs here, so create directory
              if [ ! -d $PREVIOUSLY_ADDED_FUSION_CERTS_DIR ]; then
                  dev_log_debug "c_mgmt:updatefusioncerts: Create directory: $PREVIOUSLY_ADDED_FUSION_CERTS_DIR"
                  mkdir $PREVIOUSLY_ADDED_FUSION_CERTS_DIR
              fi
              dev_log_verbose "c_mgmt:updatefusioncerts: Backup added cert $new_cert, to fusion directory: $PREVIOUSLY_ADDED_FUSION_CERTS_DIR"
              cp $new_cert  $PREVIOUSLY_ADDED_FUSION_CERTS_DIR
          else
              dev_log_debug "c_mgmt:updatefusioncerts: Cert $new_cert already in file. Don't add."
          fi
      fi
  done

  if ! cmp $TEMP_CA_FILE $CA_FILE >/dev/null 2>&1 ; then
    dev_log_debug "c_mgmt:updatefusioncerts: File different: Create new cert file $CA_FILE"
    cp $TEMP_CA_FILE $CA_FILE
  else
    dev_log_debug "c_mgmt:updatefusioncerts: No changes to CA file $CA_FILE"
  fi
}

#
# createfusioncertsdir
#    create directory /tandberg/persistent/certs/fusionadded/ for php
#
createfusioncertsdir() {
  dev_log_debug "c_mgmt:createfusioncertsdir: create $PREVIOUSLY_ADDED_FUSION_CERTS_DIR"
  mkdir -p $PREVIOUSLY_ADDED_FUSION_CERTS_DIR
}

#
# deletefusioncertsdir
#    delete directory /tandberg/persistent/certs/fusionadded/ for php
#
deletefusioncertsdir() {
  dev_log_debug "c_mgmt:deletefusioncertsdir: delete $PREVIOUSLY_ADDED_FUSION_CERTS_DIR"
  rm -fr $PREVIOUSLY_ADDED_FUSION_CERTS_DIR
}


# $1 file1
# $2 file2
search_file() {
s1=$(get_formatted_certs $1)
python <<END
with open("$2", 'r') as f:
    s2 = f.read()
print s2.find("$s1")
END
}

# $1 file1
# $2 file2
remove_file() {
s1=$(get_formatted_certs $1)
python <<END
with open("$2", 'r') as f:
    s2 = f.read()
s3 = s2.replace("$s1", '')
with open("$2", 'w') as f:
    f.write(s3)
END
clean_blank_lines $2
}

# $1 cert pem file
get_formatted_certs() {
python <<END
import re
separator = '-----END CERTIFICATE-----'
name_start = 'O='
cert_start = '-----BEGIN CERTIFICATE-----'
with open("$1", 'rU') as cert_file:
    cert_data = cert_file.read()
    parsed = reduce(lambda acc, elem: acc[:-1] + [acc[-1] + elem] if elem == separator else acc + [elem],
                    re.split('(%s)' % re.escape(separator), cert_data), [])
    certs = []

    for parse in parsed:
        if name_start in parse:
            # remove extra text before O=
            finished_cert = re.sub(r'.*%s' % name_start, '%s' % name_start, parse, flags=re.DOTALL)
            if certs:
                certs.append('\n\n' + finished_cert)
            else:
                certs.append('\n' + finished_cert)
        elif cert_start in parse:
            # remove extra text before -----BEGIN CERTIFICATE-----
            finished_cert = re.sub(r'.*%s' % cert_start, '%s' % cert_start, parse, flags=re.DOTALL)
            if certs:
                certs.append('\n\n' + finished_cert)
            else:
                certs.append('\n' + finished_cert)

    for cert in certs:
        print repr(cert)[1:-1]
END
}

repaircerts(){
python <<END
import re
separator = "-----END"
separator_wildcard = re.compile("(-----END.*-----)")
name_start = "O="
pem_start = "-----BEGIN"

with open("$CA_FILE", "rU") as cert_file:
    cert_data = cert_file.read()
    parsed = reduce(lambda acc, elem: acc[:-1] + [acc[-1] + elem] if separator in elem else acc + [elem],
                    re.split(separator_wildcard, cert_data), [])
    certs = []

    for parse in parsed:
        if name_start in parse:
            # remove extra text before O=
            finished_cert = re.sub(r".*%s" % name_start, "%s" % name_start, parse, flags=re.DOTALL)
            certs.append('\n' + finished_cert + '\n')
        elif pem_start in parse:
            # remove extra text before -----BEGIN
            finished_cert = re.sub(r".*%s" % pem_start, "%s" % pem_start, parse, flags=re.DOTALL)
            certs.append('\n' + finished_cert + '\n')
    with open("$TEMP_CA_FILE", "w") as rf:
        for cert in certs:
            rf.write(cert)
END
if ! cmp $TEMP_CA_FILE $CA_FILE >/dev/null 2>&1 ; then
    dev_log_debug "c_mgmt:repaircerts: File different: Create new cert file $CA_FILE"
    cp $TEMP_CA_FILE $CA_FILE
else
    dev_log_debug "c_mgmt:repaircerts: No changes to CA file $CA_FILE"
fi
}

# $1 cert pem file
clean_blank_lines() {
python <<END
with open("$1", 'r') as f:
    s1 = f.read()
s2 = s1.replace('\n\n\n', '\n\n')
with open("$1", 'w') as f:
    f.write(s2)
END
}

is_box_type_set() {
    local box_type_str="$1"
    wget -o /dev/null -q -O - http://localhost:4370/configuration/serviceselect | grep -q "\"box_type\":\"${box_type_str}\""
    return $?
}

case $1 in
    addfusioncerts)
        addfusioncerts
        ;;
    removefusioncerts)
        removefusioncerts
        ;;
    repaircerts)
        repaircerts
        ;;
    createfusioncertsdir)
        createfusioncertsdir
        ;;
    deletefusioncertsdir)
        deletefusioncertsdir
        ;;
    *)
        if user_exists _c_mgmt; then
            dev_log_debug "c_mgmt:general"
            # Ensure ca.pem is updated on an e
            # check expressway type in 12.6+ versions
            if is_box_type_set "e" ; then
                updatefusioncerts
            # check expressway type till 12.5 versions
            elif is_option_key_set "T00" ; then
                updatefusioncerts
            else
                # Cleanup any fusion certs which were added to ca.pem by older installations
                # Does certs directory exist?
                if [ -d "$PREVIOUSLY_ADDED_FUSION_CERTS_DIR" ]; then
                    # Is the certs directory empty? If not clean up.
                    if [ "$(ls -A $PREVIOUSLY_ADDED_FUSION_CERTS_DIR)" ]; then
                        removefusioncerts
                    fi
                    createfusioncertsdir
                fi
            fi
            run_service "c_mgmt" $1
        else
            #
            # installwizard:
            # no point trying to do any of this if
            # _c_mgmt user isn't there
            #
            dev_log_debug "c_mgmt: user _c_mgmt does not exist"
        fi
        ;;
esac
