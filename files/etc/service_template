#!/bin/sh
#
# This file is the default script to run all plugin services
#

# Source

[ -f "/etc/sysconfig" ] && . "/etc/sysconfig"
[ -f "/etc/functions" ] && . "/etc/functions"
[ -f "/tandberg/persistent/configuration" ] && . "/tandberg/persistent/configuration"

# Functions

# Override /etc/functions method to support both Hybrid and Developer log.
dev_log_debug() {
    # Write $1 to appropriate log at debug priority, based of Major.Minor version of Expressway
    facility="local7.debug"
    version=$(echo $(cat /info/product_info.xml) | sed "s;.*<version>.*<major>\([^<]*\)</major>.*<minor>\([^<]*\)</minor>.*;\1.\2;")
    if [ ${version} == "8.6" ] || [ ${version} == "8.7" ]; then
        facility="local5.debug"
    fi
    logger -p ${facility} "UTCTime=\"`date -u '+%F %T,000'`\" Level=\"DEBUG\" Detail=\"$1\""
}

is_service_lost_in_background()
{
    local service=$1
    local pidfile=$2
    local username="_${service}"

    ret_val=`ps -u ${username} | wc -l 2> /dev/null`

    # If the process is running and a pidfile does not exist, wait for service to fix itself.
    i=0
    while [ "${ret_val}" -gt 1 ] && [ ! -f ${pidfile} ] && [ ${i} -lt 10 ]
    do
        # Log only once inside loop to prevent noise.
        if [ ${i} -eq 0 ]; then
            dev_log_debug "Service ${service} already running in the background without a pidfile created."
        fi
        sleep 1
        let i=i+1
    done
    if [ ${i} -ge 10 ]; then
        dev_log_debug "Service ${service} still running in the background without a pidfile created."
        return 0
    fi
    return 1
}

is_start_event_occurring()
{
    # Check if the Busy file exists to ensure against two calls for once service occurring concurrently.
    ret_val=1
    if [ -f ${BUSYFILE} ]; then
        let ret_val=0
    fi
    return ${ret_val}
}

random_sleep()
{
    # This function is used to randomly sleep to offset any queued calls.
    sleep_time=$(($RANDOM % 5))
    if [ ${sleep_time} -eq 0 ]; then
        let sleep_time=1
    fi

    dev_log_debug "/etc/service_template::random_sleep() - for ${sleep_time} seconds."
    sleep ${sleep_time}
}


clean_up()
{
    dev_log_debug "/etc/service_template::clean_up on exit."
    if [ -f ${BUSYFILE} ]; then
        rm -f ${BUSYFILE}
    fi
}

trap clean_up TERM QUIT EXIT

is_service_up_ex() {
    local pid=""
    local service=$1
    local pidfile=$2
    if [ -f $pidfile ]; then
        # Always grab just one line.
        pid="`cat $pidfile | head -1 2> /dev/null`"
    fi
    if [ -z "$pid" ]; then
        return 1
    fi

    # NOTE!  $1 is the pid and $5 the command in the busybox ps.
    # This differs from other ps'es, but this is the one we use.
    #
    # This is not perfect.  If a pid has been reused by a process
    # with the same or a resembling (i.e. that matches) name, this
    # test will falsely say it runs.  But what are the odd?  Slim to
    # none.

    if ps ax | awk "BEGIN {ret=1} \$1 == $pid && \$0 ~ /$service/ {ret=0} END {exit(ret)}";then
        return 0
    else
        return 1
    fi
}

get_json_value()
{
    awk -F"[,:}]" '
    {
        for( i=1; i<=NF; i++ )
        {
            if($i~/'$1'\042/)
            {
                print $(i+1)
            }
        }
    }' | tr -d '" '
}

exe()
{
    if [ "$EXE" ]; then
        dev_log_debug "Debug: exe function passed preparing to run"
        $EXE
    else
        dev_log_debug "/etc/service_template::exe() - Default execution command being run for ${SERVICE}."
        export LD_LIBRARY_PATH=/opt/$SERVICE/lib
        export LANG=en_US.UTF-8
        
        if [ "${PIDFILE}" != "/var/run/${SERVICE}.pid" ]; then
            if [ ! -L ${PIDFILE} ]; then
                ln -fs ${PIDFILE} /var/run/${SERVICE}.pid
            fi
        fi

        if [ ! -d /cgroup/${SERVICE} ]; then
            mkdir /cgroup/${SERVICE}
            chown "${SERVICE_USERNAME}":"${SERVICE_USERNAME}" /cgroup/${SERVICE}/*
        fi

        if [ -f ${MANIFEST} ]; then
            CPU_PRIORITY=`cat ${MANIFEST} | get_json_value cpuPriorityPercentage`
            MEMORY_PERCENTAGE=`cat ${MANIFEST} | get_json_value memoryPercentageLimit`

            if [ ! -z "${CPU_PRIORITY}" ]; then
                RATIO=$((CPU_PRIORITY*1024/100))
                echo "${RATIO}" > /cgroup/${SERVICE}/cpu.shares
            fi
            if [ ! -z "${MEMORY_PERCENTAGE}" ]; then
                AVAILABLE_MEMORY=`grep MemTotal /proc/meminfo | awk '{print $2*1024}'`
                MEMORY_LIMIT=$((AVAILABLE_MEMORY/100*MEMORY_PERCENTAGE))
                echo "${MEMORY_LIMIT}" > /cgroup/${SERVICE}/memory.limit_in_bytes
            fi
        fi

        level="local7.error"
        version=$(echo $(cat /info/product_info.xml) | sed "s;.*<version>.*<major>\([^<]*\)</major>.*<minor>\([^<]*\)</minor>.*;\1.\2;")
        if [ ${version} == "8.6" ] || [ ${version} == "8.7" ]; then
            level="local5.error"
        fi

        if [ -f "${BIN}.sh" ]; then
            dev_log_debug "Debug: ${BIN}.sh being called."
            python /bin/firestarter.py --lives=10 --time=10 --instancelimit=1 --cgroup="${SERVICE}" --user="${SERVICE_USERNAME}" --command="${BIN}.sh $PIDFILE" --pipeto="/bin/logger -p \"${level}\"" &
        elif [ -f $BIN ]; then
            dev_log_debug "Debug: ${BIN} -P binary called."
            python /bin/firestarter.py --lives=10 --time=10 --instancelimit=1 --cgroup="${SERVICE}" --user="${SERVICE_USERNAME}" --pidfile=${PIDFILE} --command="${BIN} -P $PIDFILE" --pipeto="/bin/logger -p \"${level}\"" &
        else
            dev_log_error "/etc/service_template::exe() - Binary convention not followed. No ${BIN} shell or binary found."
            exit 1
        fi
        # make sure PID file has been created before return.
        i=0
        while [ ! -f ${PIDFILE} ] && [ ${i} -lt 10 ]
        do
            sleep 1
            let i=i+1
        done
        if [ ${i} -ge 10 ]; then
            echo "Failed to start ${SERVICE}"
            dev_log_error "Failed to start ${SERVICE}"
            exit 1
        fi
    fi
}

update()
{
    if [ $5 ]; then
        $UPDATE
    fi
}

start()
{
    if [ -f /tandberg/etc/nostart ]; then
        echo "/tandberg/etc/nostart exists. Exiting."
        dev_log_debug "/tandberg/etc/nostart exists. Exiting."
        exit 0
    fi

    echo "Starting ${SERVICE}"

    [ $PRESTART ] && $PRESTART

    do_run ${SERVICE} || exit 0

    # Time sensitive events occur below, ensure there is only one instance running.
    if is_start_event_occurring; then
        dev_log_debug "${SERVICE} - Start event already running. Not Starting"
        random_sleep
        exit 0
    else
        touch ${BUSYFILE}
    fi

    if is_service_lost_in_background ${SERVICE} ${PIDFILE}; then
        dev_log_debug "${SERVICE} still running in the background, killing zombie process."
        pkill -9 -u ${SERVICE_USERNAME}
        sleep 3
    fi

    if is_service_up_ex $SERVICE $PIDFILE; then
        dev_log_debug "${SERVICE}::start() - Service $SERVICE already running.  Not starting."
        rm -f ${BUSYFILE}
        exit 0
    fi

    if [ ! -d "$PIDDIR" ]; then
        mkdir $PIDDIR
        chown "${SERVICE_USERNAME}" $PIDDIR
    fi

    rm -f ${BUSYFILE}
    exe
}

stop()
{
    STOPSCRIPT=${BIN}stop.sh

    if is_start_event_occurring; then
        dev_log_debug "${SERVICE} - Start event already running. Not Starting"
        random_sleep
        exit 0
    else
        touch ${BUSYFILE}
    fi

    if is_service_up_ex $SERVICE $PIDFILE; then

        if [ -f $STOPSCRIPT ]; then
            dev_log_debug "/etc/service_template::()stop - Calling stop script for $SERVICE"
            $STOPSCRIPT
        else
            dev_log_debug "/etc/service_template::stop() - Stopping $SERVICE"
            local shutdown_timeout=10
            stop_service $SERVICE $PIDFILE "" $shutdown_timeout 2>/dev/null
        fi
        if [ -d /cgroup/${SERVICE} ]; then
            rmdir /cgroup/${SERVICE} 2>/dev/null
        fi
    else
        dev_log_debug "/etc/service_template::stop() - Service: $SERVICE already stopped."
    fi
    rm -f ${BUSYFILE}
}

# Args 1=SERVICE 2=OPTION 3=PRESTART 4=EXE 5=UPDATE
run_service()
{
    if upgrade_in_progress; then
        exit 0
    fi

    VERSIONED_SERVICE=$1

    SERVICE=$1
    SERVICE_USERNAME="_${SERVICE}"
     
    PIDDIR=/var/run/${VERSIONED_SERVICE}
    PIDFILE=${PIDDIR}/${SERVICE}.pid
    BIN=/opt/${VERSIONED_SERVICE}/bin/${SERVICE}
    MANIFEST=/mnt/harddisk/current/fusion/manifest/${SERVICE}.json

    BUSYBASE="/tmp/service-restart-busy-"
    BUSYFILE="${BUSYBASE}${SERVICE}"

    if [ $# -lt 2 ]; then
        dev_log_debug "/etc/service_template::run_service() - Function Called with too few arguments"
        exit 0 
    fi  

    if [ $3 ]; then
        PRESTART=$3 
    fi

    if [ $4 ]; then
        EXE=$4
    fi

    if [ $5 ]; then
        UPDATE=$5
    fi      

    case $2 in
        start)
            start
            ;;
        stop)
            stop
            ;;
        restart)
            stop
            start
            ;;
        update)
            update
            ;;
        *)
            echo "Usage: $0 {start|stop|restart|update}" >&2
            dev_log_error "/etc/service_template::run_service() - Function called with invalid argument option. Exiting."
            exit 1
            ;;
    esac
    
    exit 0
}
