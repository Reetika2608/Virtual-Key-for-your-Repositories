#!/usr/bin/groovy
@Library('sparkPipeline') _

pipelineProperties(
                   integration: [
                   runSecurityScans: true])

RELEASE_CHANNEL = params.RELEASE_CHANNEL
CONNECTOR_TYPE = params.CONNECTOR_TYPE
TLP_FILE = ''

timestamps {
    try {
        stage('Copy FMC TLP') {
            node('SPARK_BUILDER') {
                sh(script: """
                if [ -f c_mgmt_*.tlp]; then
                    rm -rf c_mgmt_*.tlp
                fi
                """.trim())
                sh(script: """
                if [ -f library.yml]; then
                    rm -rf library.yml
                fi
                """.trim())

                copyArtifacts(filter: '*.tlp',
                        fingerprintArtifacts: true,
                        flatten: true,
                        projectName: 'team/management-connector/pipeline/master',
                        selector: [$class                   : 'TriggeredBuildSelector',
                                   allowUpstreamDependencies: false,
                                   fallbackToLastSuccessful : true,
                                   upstreamFilterStrategy   : 'UseGlobalSetting'])
              //copy  library.yml
              copyArtifacts(filter: 'library.yml',
                        fingerprintArtifacts: true,
                        flatten: true,
                        projectName: 'team/management-connector/pipeline/master',
                        selector: [$class                   : 'TriggeredBuildSelector',
                                   allowUpstreamDependencies: false,
                                   fallbackToLastSuccessful : true,
                                   upstreamFilterStrategy   : 'UseGlobalSetting'])

                TLP_FILE = sh(script: "ls c_mgmt_*.tlp", returnStdout: true).trim()
                stash(includes: "${TLP_FILE}", name: 'tlp')
                stash(includes: 'library.yml', name: 'library')
            }
        }

        stage('Prepare Provisioning') {
            node('SPARK_BUILDER') {
                // Disabling security scan for c_ccucmgmt as the .tlp is same for both connector types

                if (CONNECTOR_TYPE == "c_ccucmgmt"){
                    pipelineProperties(
                                       integration: [
                                       runSecurityScans: false])
                }
                checkout scm
                unstash('tlp')
                unstash('library')
                // maven is the current approach for static url file storage of release channel tlp, for the binary
                // deploy job, alternatively you could have a downstream jenkins job archiving all TLP also
                print("Step 1. Publish c_mgmt.tlp to maven")
                sh("cp ${TLP_FILE} c_mgmt.tlp")
                def utils = load('jenkins/methods/utils.groovy')
                def credentialsId = 'cafefusion.gen.job.executor'
                def remoteJenkinsUrl = "https://sqbu-jenkins.wbx2.com/support/"
                utils.uploadArtifactsToMaven('c_mgmt.tlp', "${RELEASE_CHANNEL}/")

                print("Step 2. Trigger Binaries Deploy Job")

                def binary_build
                def binary_job_url = "platform/binaries/binaries-deploy-management-connector-prod-${RELEASE_CHANNEL}"

                binary_build = 'org.jenkinsci.plugins.ParameterizedRemoteTrigger.pipeline.RemoteBuildPipelineStep' (
                        abortTriggeredJob: true,
                        auth: CredentialsAuth(credentials: credentialsId),
                        remoteJenkinsUrl: "${remoteJenkinsUrl}",
                        job: "${binary_job_url}",
                        useCrumbCache: false,
                        useJobInfoCache: true,
                        maxConn: 2,
                        pollInterval: 15,
                        blockBuildUntilComplete: true
                )

                def build_number = binary_build.getBuildNumber()
                if (build_number == 0) {
                    error("Unexpected remote build number: 0")
                } else {
                    sh("rm -rf manifest.yaml*")
                    print ("Step 3. Copy the artifacts from Remote Server")
                    withCredentials([usernamePassword(credentialsId: 'cafefusion.gen.job.executor',  usernameVariable: 'username', passwordVariable:'token')]) {
                        sh """
                        curl -X GET -u $username:$token https://sqbu-jenkins.wbx2.com/support/job/platform/job/binaries/job/binaries-deploy-management-connector-prod-${RELEASE_CHANNEL}/${build_number}/artifact/_dist/manifest.yaml -O """
                    }

                    print("Step 4. Create provisioning JSON file")
                    createProvisioning(RELEASE_CHANNEL, CONNECTOR_TYPE)

                    archiveArtifacts(artifacts: "${TLP_FILE}, library.yml, *targeted.txt, *provisioning.txt, manifest.yaml")
                }
            }
        }
    }
    finally {
        node('SPARK_BUILDER') {
            print('Cleaning ws')
            cleanWs()
        }
    }
}

/********************************************************************************/

def getManifestUrl() {
    print("Retrieving published url from manifest.yaml file for ${RELEASE_CHANNEL} from binaries-deploy-management-connector")
    def data = readYaml(file: 'manifest.yaml')
    print("Read manifest.yaml. Content: ${data}")
    def published_url = data.results.published[0]
    return published_url
}

def createProvisioning(String release, String connector_type) {
    def published_url = getManifestUrl()
    def connector_version = getTlpVersionFromTLP(TLP_FILE)
    createProvisioningJson(release, published_url, connector_type, connector_version)
}

def getTlpVersionFromTLP(String tlp) {
    def version = tlp.tokenize('_')[-1].replace('.tlp', '').trim()

    print("TLP version from URL: ${version}")
    return version
}

def createProvisioningJson(String release, String tlp_url, String type, String version) {

    def dis_name = ''
    if (type == 'c_ccucmgmt') {
        dis_name = 'CCUC Management Connector'
    } else {
        dis_name = 'Management Connector'
    }
    def filename = "${release}_provisioning.txt"
    def con_type = "${type}"
    def ser_id = 'squared-fusion-mgmt'
    def con_desc = ''
    def rel_notes = 'This Management Connector update includes ongoing improvements and minor bug fixes.'
    def pkg_type = 'connector'
    def rel_chn = release
    def urgent = 'false'

    def data = "{'tlp_url':'${tlp_url}', 'version':'${version}', 'connector_type': '${con_type}', 'display_name':'${dis_name}', " +
            "'service_id':'${ser_id}', 'description':'${con_desc}', 'release_notes':'${rel_notes}', 'package_type':'${pkg_type}', " +
            "'release_channel':'${rel_chn}', 'dependencies':[], 'targets':['${con_type}'], 'urgent':'${urgent}'}"

    def json_data = readJSON(text: data)

    print("Creating ${filename} with content: ${json_data}")
    writeJSON(file: filename, json: json_data)

    if (release == 'latest') {
        // Create a second file with urgent changed to true, and write it to latest_provisioning_targeted.txt
        createTargetedProvisioningJson(tlp_url, con_type, version)
    }
}

def createTargetedProvisioningJson(String tlp_url, String type, String version) {

    def dis_name = ''
    if (type == 'c_ccucmgmt') {
        dis_name = 'CCUC Management Connector'
    } else {
        dis_name = 'Management Connector'
    }
    def targeted_file = 'latest_provisioning_targeted.txt'
    def cluster_id = '362ac799-8488-43ab-a215-5e58ae0aed0a'
    def org_id = '8e52edcc-bb11-4721-babe-722ec8fba823'
    def auto_upgrade = 'true'
    def con_type = "${type}"
    def ser_id = 'squared-fusion-mgmt'
    def con_desc = ''
    def rel_notes = 'None'
    def pkg_type = 'connector'
    def rel_chn = 'latest'

    def data = "{'tlp_url':'${tlp_url}', 'version':'${version}', 'connector_type': '${con_type}', 'display_name':'${dis_name}', " +
            "'service_id':'${ser_id}', 'description':'${con_desc}', 'release_notes':'${rel_notes}', 'package_type':'${pkg_type}', " +
            "'release_channel':'${rel_chn}', 'dependencies':[], 'targets':['${con_type}'], 'cluster_id': '${cluster_id}', " +
            "'organization_id':'${org_id}', 'auto_upgrade':'${auto_upgrade}'}"

    def json_data = readJSON(text: data)

    print("Creating ${targeted_file} with content: ${json_data}")
    writeJSON(file: targeted_file, json: json_data)
}