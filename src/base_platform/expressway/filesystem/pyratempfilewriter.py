"""
File writer for files that are generated from a Pyratemp template.
"""

# Ignore "Class has no __init__ method" warnings.     pylint: disable=W0232

import time
import logging
import pyratemp

from base_platform.expressway.filesystem.filewriter import FileWriter

ADMIN_LOGGER = logging.getLogger('administrator.management.linuxmanager')


def escape_strip_newlines(string, _format):
    """
    Pyratemp escape function that removes new lines and null bytes from data.
    If you want to use this in your file writer, set its ``escape_func`` class
    variable to this function.
    """

    string = string.replace('\n', '')
    string = string.replace('\r', '')
    string = string.replace('\0', '')
    return str(string)


class PyratempFileWriter(FileWriter):
    """
    File writer that makes it easier to write files from pyratemp templates.
    See http://www.simple-is-better.org/template/pyratemp.html for templating
    syntax.

    You should subclass PyratempFileWriter and make sure you set at least the
    :attr:`template` class variable.

    Ensue your template contains "daemon_version" in order to automatically fill
    out the header version and have a comparision check on system restart

    Example for an imaginary config file::

        class MyFileWriter(PyratempFileWriter):
            template = '''\\
                $!header_lines!$

                <!--(if mode == "On")-->
                    username = $!username!$
                    password = $!password!$
                <!--(end)-->
            '''

        writer = MyFileWriter("/etc/myfile")
        writer.write_file({
            "mode":     "On",
            "username": "admin",
            "password": "foo",
        })

    .. py:attribute:: template

        The pyratemp template to use when writing the file.  Subclasses must set
        this.  See http://www.simple-is-better.org/template/pyratemp.html for
        the syntax of the template.

    .. py:attribute:: escape_func

        If this is not None, it is used to escape @!variables!@ in the template
        text.  By default no escaping is done.  See
        :func:`escape_strip_newlines` for an example of an escape function.

    .. py:attribute:: strip_line_indentation

        If this is set to True then all indentation is stripped from the
        beginning of lines in the output.  Useful when you want to indent
        pyratemp directives in your template text.
    """

    template = None
    escape_func = None
    strip_line_indentation = True
    daemon_version = None
    service = ""

    _write_dictionary = False

    header = """\
# This file is automatically generated. Manual changes will be lost.
# Generated at %(generated_time)s by %(generator_name)s
#
"""

    header_version = """\
# daemon version %(daemon_version)s"""

    def _isvalid_conf_file(self, originalconfig):
        """ Check the content of the current conf file with that generated from originalconfig
            (Ignore comment and blank lines- that way we don't check the datestamp)
        """
        config_lines = []
        config_version = []
        test_version = []
        test_lines = []
        try:
            with open(self.get_file_path()) as conf_file:
                for line in conf_file:
                    line = line.strip()
                    if line == '':
                        continue
                    elif line.startswith('# daemon version'):
                        config_version.append(line.rstrip())
                    if not line.startswith('#'):
                        config_lines.append(line.rstrip())
            self._write_dictionary = True
            testconfig = PyratempFileWriter.write_file(self, originalconfig)
            self._write_dictionary = False
            if testconfig is None:
                raise IOError
            for line in testconfig:
                line = line.strip()
                if line == '':
                    continue
                elif line.startswith('# daemon version'):
                    test_version.append(line.rstrip())
                if not line.startswith('#'):
                    test_lines.append(line.rstrip())
        except IOError:
            return (False, False)
        else:
            return (config_version == test_version, config_lines == test_lines)

    def init_file(self, config):
        """
        Called to initialise the file to a known state that matches the supplied configuration.
        """
        # file tests
        (version_ok, content_ok) = self._isvalid_conf_file(config)
        if not version_ok or not content_ok:
            PyratempFileWriter.write_file(self, config)
            return not content_ok
        else:
            return False

    def write_file(self, config):
        """
        Renders the template and writes the file.  The "config" dictionary is
        used as the template's data, with the following additions:

        * ``generated_time`` - The current time
        * ``generator_name`` - The name of this class
        * ``header_lines`` - A comment that contains the above two fields
        """

        assert (self.template is not None)

        # Add our own data
        data = dict(config)
        # data['daemon_version'] = self.daemon_version
        data["generated_time"] = \
            time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime())
        data["generator_name"] = \
            "%s.%s" % (self.__class__.__module__, self.__class__.__name__)
        data["header_lines"] = self.header % data
        if self.daemon_version is not None:
            data["header_lines"] += (self.header_version % {'daemon_version': self.daemon_version})

        # Use the escape function if one was provided
        kwargs = {"data": data}
        if self.escape_func is not None:
            if hasattr(self.escape_func, "__func__"):
                kwargs["escape_func"] = self.escape_func.__func__
            else:
                kwargs["escape_func"] = self.escape_func

        # Render the template
        template = pyratemp.Template(self.template, **kwargs)
        content = template()

        if self.strip_line_indentation:
            # Remove indentation from the beginning of lines
            content = "\n".join([x.lstrip() for x in content.splitlines()])

        # Write the file
        if self._write_dictionary:
            return content.split('\n')
        else:
            FileWriter.write_file(self, content)

    def generate_config(self, *_args):
        """ divert to client provided generator function """
        assert (False), "No generate_config method provided by %s" % self.__class__

    def init_config_file(self, *args):
        """
        Initialise (write if different) the configuration file from the supplied configuration
        """
        config_file_rewrite = self.init_file(self.generate_config(*args))
        if config_file_rewrite:
            ADMIN_LOGGER.info('Detail="Initialising %s config file" Filename="%s"' %
                              (self.service, self.get_file_path()))
        return config_file_rewrite

    def write_config_file(self, *args):
        """ Write the configuration file from the supplied configuration """
        config_file_rewrite = self.init_file(self.generate_config(*args))
        if config_file_rewrite:
            ADMIN_LOGGER.info('Detail="Updating %s configuration file" Filename="%s"' %
                              (self.service, self.get_file_path()))
        return config_file_rewrite

    # Method aliases
    init_config = init_config_file
    write_config = write_config_file
    write = write_file
